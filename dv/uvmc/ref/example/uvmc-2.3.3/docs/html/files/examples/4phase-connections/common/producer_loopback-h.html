<html><head><title>SC -&gt; SV -&gt; SC 4-phase loopback example</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="SC.SV.SC_4-phase_loopback_example" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.h">SC -&gt; SV -&gt; SC 4-phase loopback example</a></h1><div class=CBody>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#SC.SV.SC_4-phase_loopback_example" >SC -&gt; SV -&gt; SC 4-phase loopback example</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription></td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Description_of_SC_producer_module" >Description of SC producer module</a></td><td class=SDescription>This is a generic <i>producer</i> module that creates <i>tlm_generic_payload</i> transactions and sends them out its <i>out</i> initiator socket in th SC -&gt; SV direction. </td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#How_the_test_works" >How the test works</a></td><td class=SDescription>The above operation is implemented in the <i>producer</i> module&rsquo;s <i>run()</i> method which is set up as an <i>SC_THREAD</i>.</td></tr>
  <!-- index=3 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#2-phase.b_transport()loopback_target_callback" >2-phase ::b_transport() loopback target callback</a></td><td class=SDescription>Since the <i>in</i> port is declared as a <i>simple_target_socket</i> to serve the 2-phase loopback coming from the SV side we must provide a <i>b_transport()</i> callback for this purpose. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="Description_of_SC_producer_module" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.h">Description of SC producer module</a></h2><div class=CBody><p>This is a generic <i>producer</i> module that creates <i>tlm_generic_payload</i> transactions and sends them out its <i>out</i> initiator socket in th SC -&gt; SV direction.&nbsp; It then receives looped back transactions via its <i>in</i> target socket in the SV -&gt; SC direction.</p><p>The SC -&gt; SV direction uses 4-phase semantics as described in the TLM-2.0 base protocol, namely BEGIN_REQ, END_REQ, BEGIN_RESP, END_RESP.&nbsp; As such it is implemented with a <i>callin</i> to <i>nb_transport_fw()</i> via its SC initiator port feeding the SV target port for the REQ phases, followed by a <i>callback</i> to <i>nb_transport_bw()</i> on the same initiator port for the RESP phases.</p><p>In between the REQ and RESP phases described above, for the SV -&gt; SC direction the SV initiator port simply uses 2-phase <i>b_transport()</i> operation to loop back the transaction.</p><p>The original SC -&gt; SV direction RESP phases are only completed after the SV -&gt; SC loopback <i>b_transport()</i> operation completes.</p><p>This operation is depicted here,</p><blockquote><pre>  i == initiator('out')                          -&gt; 'callin'
  t == target('in')                              :: 'callback'

                   SC          language           SV
                producer       boundary        loopback
    /                             |
   |  i-&gt;nb_transport_fw(t) ----&gt; | ----&gt; t::nb_transport_fw(t) - +
   |                         REQ  |                               |
   |                              |                               |
   |                              |                               |
4  |   2                          |                               |
-  |   -  /                       |                               |
p /    p /  t::b_transport(t) &lt;-- | &lt;-- i-&gt;b_transport(t) - - - - +
h \    h \        |               |
a  |   a  \       + return    --&gt; | --&gt; return  - - - - - - - - - +
s  |   s                          |                               |
e  |   e                          |                               |
   |                              |                               |
   |                         RESP |                               |
   |  i::nb_transport_bw(t) &lt;---- | &lt;---- t-&gt;nb_transport_bw(t) - +
    \</pre></blockquote><p>For transaction preservation to work correctly in the <i>producer</i> initiator&rsquo;s <i>nb_transport_bw()</i> callback it is expected that the transaction ref <i>t</i> is the same as that originally passed via the initiator&rsquo;s call to <i>nb_transport_fw()</i>.&nbsp; Thus the <i>t</i> ref is <i>preserved</i>.&nbsp; If the <i>loopback</i> module does not follow this rule a WARNING will result as well as potential memory leak.</p><blockquote><pre>class producer : public sc_module {
  public:
  simple_initiator_socket&lt;producer&gt; out; // uses tlm_gp
  simple_target_socket&lt;producer&gt; in; // defaults to tlm_gp

  int num_trans;
  sc_event done;
  sc_event respWasReceived;

  tlm_generic_payload *currentGp;

  unsigned long long expected_checksum, actual_checksum;

  producer(sc_module_name nm) : out(&quot;out&quot;), in(&quot;in&quot;),
                                num_trans(NUM_TRANSACTIONS),
                                expected_checksum(0LL),
                                actual_checksum(0LL) {
    SC_THREAD(run);
    in.register_b_transport(this, &amp;producer::b_transport);
    out.register_nb_transport_bw(this, &amp;producer::nb_transport_bw);
  }

  SC_HAS_PROCESS(producer);</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="How_the_test_works" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.h">How the test works</a></h2><div class=CBody><p>The above operation is implemented in the <i>producer</i> module&rsquo;s <i>run()</i> method which is set up as an <i>SC_THREAD</i>.</p><p>Notice that the <i>producer</i> must also furnish the <i>nb_transport_bw()</i> callback function for its <i>out</i> initiator port.</p><p>The main <i>run()</i> test thread function will work in 2 ways,</p><ul><li>First 32 transactions will be sent without enabling memory management in the UVM-Connect&rsquo;ion.&nbsp; This means the user will get warnings because allocated transactions in the infrastructure will not match transactions sent by the the <i>loopback</i> module in the RESP phases which result in calls to <i>producer::nb_transport_bw()</i>.</li><li>Remaining 96 transactions will have memory management enabled and therefore will reflect TLM GPs received in REQ phase (calls to <i>nb_transport_fw()</i> back to the RESP phase (callbacks to <i>nb_transport_bw()</i>).</li></ul><p>When the transaction is received in the <i>nb_transport_bw()</i> function the data payload is accumulated in an overall checksum which is compared at the end to an expected checksum to verify the transactions were properly received through the loopback paths.</p><blockquote><pre>  void run() {
    tlm_generic_payload gp;
    tlm_phase phase;
    tlm_sync_enum result;
    unsigned char *data = new unsigned char [PAYLOAD_NUM_BYTES];
    sc_time delay;

    static bool isTransMmEnabled = false;

    currentGp = &amp;gp;

    sc_dt::uint64 address = 0x40000000;

    gp.set_command(TLM_WRITE_COMMAND);
    gp.set_data_length( PAYLOAD_NUM_BYTES );

    cout &lt;&lt; sc_time_stamp()
         &lt;&lt; &quot; [PRODUCER/GP/SEND]&quot;
         &lt;&lt; &quot; cmd: &quot; &lt;&lt; gp.get_command()
         &lt;&lt; &quot; addr:&quot; &lt;&lt; hex &lt;&lt; gp.get_address()
         &lt;&lt; &quot; PAYLOAD_NUM_BYTES:&quot; &lt;&lt; dec &lt;&lt; gp.get_data_length()
         &lt;&lt; &quot; NUM_TRANSACTIONS:&quot; &lt;&lt; dec &lt;&lt; NUM_TRANSACTIONS
         &lt;&lt; endl;

    unsigned offset = 0;

    wait( 1, SC_NS ); // Give SV side a chance to become UVM-Connect'ed

    for( int i=0; i&lt;num_trans; i++ ){
      if( i &gt;= 32 &amp;&amp; isTransMmEnabled == false ){
          uvmc_enable_trans_mm();
          isTransMmEnabled = true;
      }

      gp.set_address( address );
      gp.set_response_status( tlm::TLM_INCOMPLETE_RESPONSE );

      for( unsigned i=0; i&lt;PAYLOAD_NUM_BYTES; i++ ) {
        data[i] = (i+offset) &amp; 0xff;  // Rotating incrementing pattern.
        expected_checksum += data[i];
      }

      gp.set_data_ptr(data);
      delay = sc_time( 10, SC_NS );

      phase = BEGIN_REQ;

//    out-&gt;b_transport( gp, delay );
      result = out-&gt;nb_transport_fw( gp, phase, delay );
      if( result != TLM_UPDATED || phase != END_REQ
            || gp.get_response_status() != TLM_OK_RESPONSE )
        fprintf( stdout,
            &quot;ERROR: %s Unexpected &quot;
            &quot;response from call to out-&gt;nb_transport_fw() &quot;
            &quot;[line #%d of '%s']\n&quot;, &quot;producer::run()&quot;, __LINE__, __FILE__ );

      wait( respWasReceived );

      address += PAYLOAD_NUM_BYTES;
      offset++;
    }

    cout &lt;&lt; endl
         &lt;&lt; sc_time_stamp()
         &lt;&lt; &quot; [PRODUCER/ENDING] &quot; &lt;&lt; endl;;

    if( actual_checksum &gt; 0 &amp;&amp; actual_checksum == expected_checksum )
      fprintf( stdout,
        &quot;expected_checksum=%llx == actual_checksum=%llx test PASSED !\n&quot;,
        expected_checksum, actual_checksum );
    else
      fprintf( stdout,
        &quot;expected_checksum=%llx != actual_checksum=%llx test FAILED !\n&quot;,
        expected_checksum, actual_checksum );

    uvmc_tlm_gp_mm_base::printAllStats();
    uvmc_trans_mm_base::printAllStats();

    fflush( stdout );

    delete [] data;

    done.notify();
  }

    virtual tlm_sync_enum nb_transport_bw(
        tlm_generic_payload &amp;gp, tlm_phase &amp;phase, sc_time &amp;t)
    {
        char unsigned *data = gp.get_data_ptr();

        phase = END_RESP;
        gp.set_response_status( TLM_OK_RESPONSE );

        if( &amp;gp != currentGp )
            fprintf( stdout,
                &quot;WARNING: %s Received non-matching trans object. &quot;
                &quot;Try calling uvmc_enable_trans_mm(). &quot;
                &quot;[line #%d of '%s']\n&quot;, &quot;producer::nb_transport_bw()&quot;,
                __LINE__, __FILE__ );

        for( unsigned long long i=0; i&lt;gp.get_data_length(); i++ )
            actual_checksum += data[i];

        respWasReceived.notify();
        return TLM_COMPLETED;
    }</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="2-phase.b_transport()loopback_target_callback" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.h">2-phase ::b_transport() loopback target callback</a></h2><div class=CBody><p>Since the <i>in</i> port is declared as a <i>simple_target_socket</i> to serve the 2-phase loopback coming from the SV side we must provide a <i>b_transport()</i> callback for this purpose.&nbsp; In this case nothing is done to transform the data.&nbsp; But the delay specified by the <i>sc_time</i> argument is used to advance time and is then reset to 0 before returning.</p><blockquote><pre>    virtual void b_transport(tlm_generic_payload &amp;gp, sc_time &amp;t) {
        char unsigned *data = gp.get_data_ptr();

//      for( unsigned long long i=0; i&lt;gp.get_data_length(); i++ )
//          actual_checksum += data[i];

        wait(t);
        t = SC_ZERO_TIME;
        gp.set_response_status( tlm::TLM_OK_RESPONSE );
    }
};</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>