<html><head><title>SV -&gt; SC -&gt; SV 4-phase loopback example</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="SV.SC.SV_4-phase_loopback_example" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.svh">SV -&gt; SC -&gt; SV 4-phase loopback example</a></h1><div class=CBody>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#SV.SC.SV_4-phase_loopback_example" >SV -&gt; SC -&gt; SV 4-phase loopback example</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription></td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Description_of_SV_producer_module" >Description of SV producer module</a></td><td class=SDescription>This is a generic <i>producer</i> module that creates <i>tlm_generic_payload</i> transactions and sends them out its <i>out</i> initiator socket in th SV -&gt; SC direction. </td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#How_the_test_works" >How the test works</a></td><td class=SDescription>The above operation is implemented in the <i>producer</i> module&rsquo;s <i>run_phase()</i> method which is set up as an SV UVM phase callback thread.</td></tr>
  <!-- index=3 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#2-phase.b_transport()loopback_target_callback" >2-phase ::b_transport() loopback target callback</a></td><td class=SDescription>Since the <i>in</i> port is declared as a <i>uvm_tlm_b_target_socket</i> to serve the 2-phase loopback coming from the SC side we must provide a <i>b_transport()</i> callback for this purpose. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="Description_of_SV_producer_module" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.svh">Description of SV producer module</a></h2><div class=CBody><p>This is a generic <i>producer</i> module that creates <i>tlm_generic_payload</i> transactions and sends them out its <i>out</i> initiator socket in th SV -&gt; SC direction.&nbsp; It then receives looped back transactions via its <i>in</i> target socket in the SC -&gt; SV direction.</p><p>The SV -&gt; SC direction uses 4-phase semantics as described in the TLM-2.0 base protocol, namely BEGIN_REQ, END_REQ, BEGIN_RESP, END_RESP.&nbsp; As such it is implemented with a <i>callin</i> to <i>nb_transport_fw()</i> via its SV initiator port feeding the SC target port for the REQ phases, followed by a <i>callback</i> to <i>nb_transport_bw()</i> on the same initiator port for the RESP phases.</p><p>In between the REQ and RESP phases described above, for the SC -&gt; SV direction the SV initiator port simply uses 2-phase <i>b_transport()</i> operation to loop back the transaction.</p><p>The original SV -&gt; SC direction RESP phases are only completed after the SC -&gt; SV loopback <i>b_transport()</i> operation completes.</p><p>This operation is depicted here,</p><blockquote><pre>  i == initiator('out')                          -&gt; 'callin'
  t == target('in')                              :: 'callback'

                   SV          language           SC
                producer       boundary        loopback
    /                             |
   |  i-&gt;nb_transport_fw(t) ----&gt; | ----&gt; t::nb_transport_fw(t) - +
   |                         REQ  |                               |
   |                              |                               |
   |                              |                               |
4  |   2                          |                               |
-  |   -  /                       |                               |
p /    p /  t::b_transport(t) &lt;-- | &lt;-- i-&gt;b_transport(t) - - - - +
h \    h \        |               |
a  |   a  \       + return    --&gt; | --&gt; return  - - - - - - - - - +
s  |   s                          |                               |
e  |   e                          |                               |
   |                              |                               |
   |                         RESP |                               |
   |  i::nb_transport_bw(t) &lt;---- | &lt;---- t-&gt;nb_transport_bw(t) - +
    \</pre></blockquote><p>For transaction preservation to work correctly in the <i>producer</i> initiator&rsquo;s <i>nb_transport_bw()</i> callback it is expected that the transaction ref <i>t</i> is the same as that originally passed via the initiator&rsquo;s call to <i>nb_transport_bw()</i>.&nbsp; Thus the <i>t</i> ref is <i>preserved</i>.&nbsp; If the <i>loopback</i> module does not follow this rule a WARNING will result as well as potential memory leak.</p><blockquote><pre>class producer extends uvm_component;

   uvm_tlm_nb_initiator_socket #(producer) out;
   uvm_tlm_b_target_socket #(producer) in;

   `uvm_component_utils(producer)

   local int unsigned expected_checksum, actual_checksum;
   event resp_was_received;

   function new(string name, uvm_component parent=null);
      super.new(name,parent);
      in = new(&quot;in&quot;, this);
      out = new(&quot;out&quot;, this);
   endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="How_the_test_works" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.svh">How the test works</a></h2><div class=CBody><p>The above operation is implemented in the <i>producer</i> module&rsquo;s <i>run_phase()</i> method which is set up as an SV UVM phase callback thread.</p><p>Notice that the <i>producer</i> must also furnish the <i>nb_transport_bw()</i> callback function for its <i>out</i> initiator port.</p><p>The main <i>run_phase()</i> test thread function in this case will simply send 128 consecutive transactions using 4-phase protocol.&nbsp; This means that each REQ phase is initiated by calling the <i>nb_transport_fw()</i> callin on the initiator port.</p><p>This is followed by confirmation that the <i>nb_transport_bw()</i> callback on the initiator port has received the same transaction before sending the next one.</p><p>Meanwhile this producer must also furnish a <i>b_transport()</i> callback on its target socket so that when the <i>loopback</i> module on the SC side loops back back the transaction it will be handled here.</p><p>See comments in the SC <i>loopback.h</i> module for how memory management and transaction preservation are enabled and how this modules tests for violations of transaction ref passing on the loopback side between the REQ and RESP phases.</p><blockquote><pre>task run_phase (uvm_phase phase);

   // Allocate GP once
   uvm_tlm_gp gp = new;
   uvm_tlm_time delay = new(&quot;del&quot;,1e-9);
   int num_trans = `NUM_TRANSACTIONS;
   uvm_tlm_phase_e nbt_phase;
   uvm_tlm_sync_e result;

   longint unsigned address = 64'h40000000;

   longint unsigned i, j, offset = 0;

   byte unsigned data[];

   // Keep the &quot;run&quot; phase from ending
   phase.raise_objection(this);

   // Get number of transactions desired (default=2)
   uvm_config_db #(uvm_bitstream_t)::get(this,&quot;&quot;,&quot;num_trans&quot;,num_trans);

   expected_checksum = 0;
   actual_checksum = 0;

   gp.set_command( UVM_TLM_WRITE_COMMAND );
   gp.set_data_length( `PAYLOAD_NUM_BYTES );

   data = new[`PAYLOAD_NUM_BYTES];

   `uvm_info( &quot;producer::run_phase()&quot;,
     $psprintf( &quot;[PRODUCER/GP/SEND] NUM_TRANSACTIONS=%0d PAYLOAD_NUM_BYTES=%0d ...&quot;, `NUM_TRANSACTIONS, `PAYLOAD_NUM_BYTES ), UVM_MEDIUM );

   for( i=0; i &lt; num_trans; i++ ) begin
     gp.set_address( address );
     gp.set_response_status( UVM_TLM_INCOMPLETE_RESPONSE );

     for( j=0; j &lt; `PAYLOAD_NUM_BYTES; j++) begin
       data[j] = (j+offset) &amp; 8'hff;
       expected_checksum += data[j];
     end
     gp.set_data( data );

     delay.set_abstime(10,1e-9);

     nbt_phase = BEGIN_REQ;

     result = out.nb_transport_fw( gp, nbt_phase, delay );
     if( result != UVM_TLM_UPDATED || nbt_phase != END_REQ
             || gp.get_response_status() != UVM_TLM_OK_RESPONSE )
         `uvm_error( &quot;producer::run_phase()&quot;,
             &quot;Unexpected response from call to out.nb_transport_fw()&quot; );

     @(resp_was_received);

     address += `PAYLOAD_NUM_BYTES;
     offset++;
   end

   if( actual_checksum &gt; 0 &amp;&amp; actual_checksum == expected_checksum ) begin
     `uvm_info( &quot;producer::run_phase()&quot;, $psprintf(
       &quot;... done producing transactions, expected_checksum=%0x == actual_checksum=%0x Test PASSED !&quot;,
       expected_checksum, actual_checksum ), UVM_MEDIUM );
   end
   else begin
     `uvm_error( &quot;producer::run_phase()&quot;, $psprintf(
       &quot;... done producing transactions, expected_checksum=%0x != actual_checksum=%0x Test FAILED !&quot;,
       expected_checksum, actual_checksum ) );
   end

   `uvm_info(&quot;PRODUCER/END_TEST&quot;,
             &quot;Dropping objection to ending the test&quot;,UVM_LOW)
   phase.drop_objection(this);
endtask

//------------------------------------
// This one is needed for the 'out' uvm_tlm_nb_initiator_socket channel
virtual function uvm_tlm_sync_e nb_transport_bw(
     uvm_tlm_gp trans, ref uvm_tlm_phase_e phase, input uvm_tlm_time delay );

   phase = END_RESP;
   trans.set_response_status( UVM_TLM_OK_RESPONSE );

   for( int unsigned i=0; i &lt; trans.get_data_length(); i++ )
      actual_checksum += trans.m_data[i];

   -&gt;resp_was_received;

   return UVM_TLM_COMPLETED;
endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="2-phase.b_transport()loopback_target_callback" href="../../../../uvmc/examples/4phase.connections/common/producer_loopback.svh">2-phase ::b_transport() loopback target callback</a></h2><div class=CBody><p>Since the <i>in</i> port is declared as a <i>uvm_tlm_b_target_socket</i> to serve the 2-phase loopback coming from the SC side we must provide a <i>b_transport()</i> callback for this purpose.&nbsp; In this case nothing is done to transform the data.&nbsp; But the delay specified by the <i>uvm_tlm_time</i> argument is used to advance time and is then reset to 0 before returning.</p><blockquote><pre>   virtual task b_transport( uvm_tlm_gp t, uvm_tlm_time delay );

//    for( int unsigned i=0; i &lt; t.get_data_length(); i++ )
//       actual_checksum += t.m_data[i];

      #(delay.get_abstime(1e-9));
      delay.reset();
      t.set_response_status( UVM_TLM_OK_RESPONSE );
   endtask</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>