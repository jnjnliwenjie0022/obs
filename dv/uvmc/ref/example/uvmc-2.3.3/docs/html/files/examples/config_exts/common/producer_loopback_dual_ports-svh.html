<html><head><title>SV -&gt; SC -&gt; SV loopback example with dual ports</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="SV.SC.SV_loopback_example_with_dual_ports" href="../../../../uvmc/examples/config_exts/common/producer_loopback_dual_ports.svh">SV -&gt; SC -&gt; SV loopback example with dual ports</a></h1><div class=CBody>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#SV.SC.SV_loopback_example_with_dual_ports" >SV -&gt; SC -&gt; SV loopback example with dual ports</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription></td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Example_of_dual_TLM_target_ports" >Example of dual TLM target ports</a></td><td class=SDescription>This example is a slight modification of the single port SV -&gt; SC -&gt; SV exmaple and the handling of configuration extensions is identical so no need to repeat that here.</td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#class_producer_TLM_port_containers" >class producer TLM port containers</a></td><td class=SDescription>The two port container classes below instantiate TLM target blocking transport sockets (<i>class uvm_tlm_b_target_socket</i>).</td></tr>
  <!-- index=3 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#class_producer-SV_initiator_and_target" >class producer - SV initiator and target</a></td><td class=SDescription>The <i>class producer</i> is a <i>uvm_component</i> that defines both initiator and target TLM-2 sockets since this is a loopback and the same producer plays the role of both initiator and eventual target.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h2 class=CTitle><a name="Example_of_dual_TLM_target_ports" href="../../../../uvmc/examples/config_exts/common/producer_loopback_dual_ports.svh">Example of dual TLM target ports</a></h2><div class=CBody><p>This example is a slight modification of the single port SV -&gt; SC -&gt; SV exmaple and the handling of configuration extensions is identical so no need to repeat that here.</p><p>However, what this example does demonstrate is the case of having dual TLM initiator + target socket couplings for a single parent UVM component.&nbsp; One is for WRITE operations and the other is for READ operations.&nbsp; This might be desirable in the case where a modeler would want to have a dedicated <i>::b_transport()</i> function for each type of operation, especially if time consuming WRITE and READ ops might overlap.</p><p>In SystemVerilog UVM, there is a dilema of how a TLM target model that is some derivation of <i>uvm_component</i> can define 2 TLM target sockets.&nbsp; The reason is that these sockets make the assumption that their parent class is expected to define the required target <i>::b_transport()</i> method implementation which is always assumed to have that fixed name.</p><p>In SystemC we can use convenience sockets for this where each convenience socket allows you to register the separately named transport callbacks for each target socket.</p><p>But, as mentioned UVM TLM does not allow this.&nbsp; So what this example demonstrates is to have 2 <i>uvm_component</i> derived child members of the parent <i>class producer</i> and each of those child components define a single target UVM TLM blocking transport socket (<i>class uvm_tlm_b_target_socket</i>).&nbsp; One of the containers handles WRITE operations and the other handles READ operations.</p><p>The diagram below illustrates the configuration showing two child <i>uvm_component</i>&rsquo;s acting as TLM port containers inside the parent SV producer which is also a <i>uvm_component</i>.</p><img src="../../../../images/sv-sc-sv-loopback-dual-port.jpg" width="667" height="302"></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="class_producer_TLM_port_containers" href="../../../../uvmc/examples/config_exts/common/producer_loopback_dual_ports.svh">class producer TLM port containers</a></h2><div class=CBody><p>The two port container classes below instantiate TLM target blocking transport sockets (<i>class uvm_tlm_b_target_socket</i>).</p><p>The first one, <i>class producer_write_port_container</i> handles WRITE operations exclusively.</p><p>The second one, <i>class producer_read_port_container</i> handles READ operations exclusively.</p><p>Both do so by calling the <i>::b_transport_write()</i> and <i>::b_transport_read()</i> methods of their parent class respectively.</p><blockquote><pre>typedef class producer;

class producer_write_port_container extends uvm_component; // {

    `uvm_component_utils(producer_write_port_container)

    // All ports default to TLM GP as transaction kind.
    uvm_tlm_b_target_socket #( producer_write_port_container ) in;

    producer parent = producer'(get_parent());

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        in = new(&quot;in&quot;, this);
    endfunction

    virtual task b_transport( uvm_tlm_gp t, uvm_tlm_time delay );
        parent.b_transport_write( t, delay );
    endtask
endclass // }

class producer_read_port_container extends uvm_component; // {

    `uvm_component_utils(producer_read_port_container)

    // All ports default to TLM GP as transaction kind.
    uvm_tlm_b_target_socket #( producer_read_port_container ) in;

    producer parent = producer'(get_parent());

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        in = new(&quot;in&quot;, this);
    endfunction

    virtual task b_transport( uvm_tlm_gp t, uvm_tlm_time delay );
        parent.b_transport_read( t, delay );
    endtask
endclass // }</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="class_producer-SV_initiator_and_target" href="../../../../uvmc/examples/config_exts/common/producer_loopback_dual_ports.svh">class producer - SV initiator and target</a></h2><div class=CBody><p>The <i>class producer</i> is a <i>uvm_component</i> that defines both initiator and target TLM-2 sockets since this is a loopback and the same producer plays the role of both initiator and eventual target.</p><p>However in this example we want to have separate target ports for WRITE operations and READ operations.</p><p>Notice in this case however, that rather than directly instantiating two UVM TLM target sockets, rather, the parent class producer instantiates the containers for those sockets as described above.</p><blockquote><pre>class producer extends uvm_component; // {

    `uvm_component_utils(producer)

    // All ports default to TLM GP as transaction kind.
    uvm_tlm_b_initiator_socket  #()           out;        // &quot;mainstream&quot; port
    uvm_tlm_nb_initiator_socket #( producer ) out_config; // static config port
    uvm_tlm_nb_target_socket    #( producer ) in_config;
    producer_write_port_container in_write;
    producer_read_port_container in_read;</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>