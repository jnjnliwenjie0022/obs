<html><head><title>Description of SC loopback module</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="Description_of_SC_loopback_module" href="../../../../uvmc/examples/4phase.connections/common/loopback.h">Description of SC loopback module</a></h1><div class=CBody><p>This module implements the <i>SC loopback</i> side of the diagram you saw in <i>producer_loopback.svh</i>.</p><p>Its job is to play a 4-phase protocol on its <i>in</i> target socket and to play a 2-phase protocol on its <i>out</i> initiator socket as described in <i>producer_loopback.svh</i>.</p><p>The <i>in</i> socket exports the <i>simple_target_socket</i> interface implemented by this loopback.</p><p>The <i>out</i> socket exports the <i>simple_initiator_socket</i> interface used by this loopback.</p><p>The <i>handleRequestsThread()</i> method is the workhorse SC_THREAD that handles the incoming requests.</p><p>The <i>nb_transport_fw()</i> callback works in 3 ways.</p><ul><li>1st 32 transactions will clone the transaction without relying on memory management in the UVM-Connect&rsquo;ion to do this automatically.</li><li>2nd 32 transactions will also clone the transaction without relying on memory management in the UVM-Connect&rsquo;ion to do this but here the memory management capability is enabled.&nbsp; This means user will get warnings because allocated transactions in the infrastructure will not match transactions sent by this module in the RESP phases (calls to <i>nb_transport_bw()</i>).&nbsp; This will also result in memory leaks.</li><li>Remaining 64 transactions will reflect TLM GP received in REQ phase (i.e. this call to <i>nb_transport_fw()</i>) back to the RESP phase without cloning.&nbsp; This will remove the warnings and result in no further leaks since the infrastructure will know to free these transactions and also how to preserve them so that back on the SV side the same transaction <i>t</i> will be seen on the RESP phases as were sent on the REQ phases.</li></ul><p>When leak stats are printed at the end you should only see leaks for the 2nd set of 32 transactions.</p><blockquote><pre>class loopback : public sc_module {
    SC_HAS_PROCESS(loopback);

  private:
    tlm_fifo&lt;tlm_generic_payload *&gt; dRequestQueue;

    uvmc_tlm_gp_mm dTlmGpMemoryManager;

  public:
    simple_target_socket&lt;loopback&gt; in; // defaults to tlm_gp
    simple_initiator_socket&lt;loopback&gt; out; // uses tlm_gp

    loopback( sc_module_name nm )
      : dRequestQueue(-1),
        dTlmGpMemoryManager(&quot;loopback::dTlmGpMemoryManager&quot;),
        in(&quot;in&quot;), out(&quot;out&quot;)
    {
        SC_THREAD( handleRequestsThread );
        in.register_nb_transport_fw( this, &amp;loopback::nb_transport_fw );
    }
    ~loopback(){
        uvmc_tlm_gp_mm_base::printAllStats();
        uvmc_trans_mm_base::printAllStats();
    }

    tlm_sync_enum nb_transport_fw(
        tlm::tlm_generic_payload &amp;gp,
        tlm::tlm_phase &amp;phase,
        sc_core::sc_time &amp;trans )
    {
        tlm_sync_enum ret = TLM_UPDATED;
        static bool isTransMmEnabled = false;

        static unsigned transCount = 0;

        if( transCount &gt;= 32 &amp;&amp; isTransMmEnabled == false ){
            uvmc_enable_trans_mm();
            isTransMmEnabled = true;
        }
        if( transCount &lt; 64 ){
            tlm_generic_payload *clonedTrans = dTlmGpMemoryManager.alloc();
            clonedTrans-&gt;set_mm( &amp;dTlmGpMemoryManager );
            clonedTrans-&gt;acquire();

            unsigned char *data = new unsigned char [gp.get_data_length()];
            clonedTrans-&gt;set_data_ptr( data );

            // TLM GP's ::deep_copy_from() is pretty smart - it copies the
            // config extensions as well as the TLM GP members. What it does
            // not do however is allocate payloads and byte enables. It assumes
            // those are there with sufficient space.
            clonedTrans-&gt;deep_copy_from( gp );

            // Innocent until proven guilty.
            gp.set_response_status( TLM_OK_RESPONSE );
            phase = END_REQ;

            dRequestQueue.nb_put( clonedTrans );
        }
        else {
            // Innocent until proven guilty.
            gp.set_response_status( TLM_OK_RESPONSE );
            phase = END_REQ;

            dRequestQueue.nb_put( &amp;gp );
        }
        transCount++;
        return ret;
    }

  private:

    void handleRequestsThread() {
        tlm_generic_payload *trans;
        sc_time delay = SC_ZERO_TIME;
        tlm_sync_enum ret;
        tlm_phase phase = BEGIN_RESP;

        while( 1 ) {
            trans = dRequestQueue.get();

            // Simply relay to b_transport() ...
            out-&gt;b_transport( *trans, delay );

            // Throw in some time advance ...
            wait( 10, SC_NS );

            // Handle RESP phases by calling nb_transport_bw() ...
            ret = in-&gt;nb_transport_bw( *trans, phase, delay );
            if( ret != TLM_COMPLETED || phase != END_RESP
                    || trans-&gt;get_response_status() != TLM_OK_RESPONSE ){
                fprintf( stdout,
                    &quot;ERROR: %s  Unexpected &quot;
                    &quot;response from call to in-&gt;nb_transport_bw() &quot;
                    &quot;[line #%d of '%s']\n&quot;,
                    &quot;loopback::handleRequestsThread()&quot;, __LINE__, __FILE__ );
                fflush( stdout );
            }
            if( trans-&gt;has_mm() )
                trans-&gt;release(); // Release back to heap.
        }
    }
};</pre></blockquote>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#Description_of_SC_loopback_module" >Description of SC loopback module</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This module implements the <i>SC loopback</i> side of the diagram you saw in <i>producer_loopback.svh</i>.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>