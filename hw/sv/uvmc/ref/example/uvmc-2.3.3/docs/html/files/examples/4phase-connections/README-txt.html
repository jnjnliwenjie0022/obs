<html><head><title>4-phase connections</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="4-phase_connections" href="../../../uvmc/examples/4phase.connections/README.txt">4-phase connections</a></h1><div class=CBody>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#4-phase_connections" >4-phase connections</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription></td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Introduction" >Introduction</a></td><td class=SDescription>The uvmc-2.3.3 release adds better support for the semantics of the TLM-2.0 base protocol and how it is used in the context of 4-phase transactions.</td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Enabling_memory_management_and_transaction_preservation" >Enabling memory management and transaction preservation</a></td><td class=SDescription>Memory management can be enabled from the SystemC side by calling the function,</td></tr>
  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#4-phase_connection_examples" >4-phase connection examples</a></td><td class=SDescription>In a 4-phase operation during which the RESP phases are deployed by the target&rsquo;s call to <i>nb_transport_bw()</i> then it is assumed that the passed in transaction reference will be one matched in the <i>nb_transport_fw()</i> call.</td></tr>
  <!-- index=4 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Running_the_examples" >Running the examples</a></td><td class=SDescription>For examples that demonstrate the 4-phase operation see,</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="Introduction" href="../../../uvmc/examples/4phase.connections/README.txt">Introduction</a></h2><div class=CBody><p>The uvmc-2.3.3 release adds better support for the semantics of the TLM-2.0 base protocol and how it is used in the context of 4-phase transactions.</p><p>These changes entail two types of improvements,</p><ul><li>More efficient memory management for allocation and freeing of TLM generic payload transactions and <i>uvmc_xl_config</i> objects</li><li>Preservation of transaction references across all 4 phases (BEGIN_REQ, END_REQ, BEGIN_RESP, END_RESP) of the TLM-2.0 base protocol</li></ul><p>Normally in any <u>intra</u>-language communication between TLM-2.0 for either SV &lt;-&gt; SV or SC &lt;-&gt; SC connections transaction preservation is implied to be naturally supported in accordance with the requirements of the TLM-2.0 LRM.</p><p>The idea is that <i>pointers</i> or <i>refs</i> to transactions are passed through the connectivity rather than the entire contents of the transactions.&nbsp; For obvious reasons this results in the most optimal performance since no memory-to-memory data copy operations are required across calls to the transport functions.</p><p>However, when it comes to language boundary crossings, preserving this semantic brings complications.&nbsp; Because data representations of TLM GP transactions, associated config objects, and other transaction types are different in the 2 languages (SC and SV) it is not simply a matter of passing a reference to an object across the connectivity.</p><p>Rather when one of these transaction objects crosses from SV -&gt; SC or SC -&gt; SV a <i>proxy representation</i> of the transaction has to be created <i>on-the-fly</i> after the language crossing so it can be properly represented in the language of the target port of the connection.</p><p>What this means is that during the RESP phases of the transaction (BEGIN_RESP, END_RESP) that are handled by the <i>nb_transport_bw()</i> function it is difficult to preserve the original reference to the transaction passed during the REQ phases (BEGIN_REQ, END_REQ) that are handled by the <i>nb_transport_fw()</i> function.</p><p>To support this semantic special <i>transaction preservation</i> table maps were added where the memory references are cached using special keys derived from the pointer to the original transaction.</p><p>This has implications for memory management.&nbsp; If the target of the connection is not disciplined enough to pass the same transaction reference received in its <i>nb_transport_fw()</i> function during the REQ phases back to the <i>nb_transport_bw()</i> function during the RESP phases, memory leaks will result.</p><p>Given that legacy UVMC usage does not support transaction preservation, this feature is only enabled if the application code enables the new memory management feature.</p><p>In legacy UVMC usage transaction preservation is not supported and memory management is not used.&nbsp; The advantage of this is that there are no memory leaks and performance is good.&nbsp; Basically single allocated transaction objects (per connection) are simply reused between REQ and RESP phases and even across multiple transactions.</p><p>While this tends to be more performant for basic 4-phase usage it arguably suffers from two violations of the TLM-2.0 standard,</p><ul><li>It does not support <i>out-of-order</i> transaction RESP&rsquo;s to associated REQ&rsquo;s.</li><li>It does not preserve TLM GP references between the RESP and REQ phases.</li></ul><p>With the newer modifications the default mode of operation is the legacy operation defined above.&nbsp; But if it is desired to add the new memory management and transaction preservation support a simple function call can be made at initialization time to enable this feature.</p><p>This allows for the best of both worlds,</p><ul><li>Backward compatiblity with legacy operation</li><li>Full conformance to the LRM for transaction preservation and out-of-order RESP support if that is desired</li></ul><p>However, there is a new risk now of memory leaks in the case where the target does not have the discipline to mirror the incoming transaction reference (pointer) passed in the <i>nb_transaport_fw()</i> REQ phases back to the <i>nb_transport_bw()</i> RESP phases.&nbsp; Fortunately the infrastructure itself will detect this violation and flag a warning in this case.</p><p>So to summarize, if the application enables transaction object memory management and there is an &ldquo;undisciplined&rdquo; target, user will see warnings about memory leaks.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="Enabling_memory_management_and_transaction_preservation" href="../../../uvmc/examples/4phase.connections/README.txt">Enabling memory management and transaction preservation</a></h2><div class=CBody><p>Memory management can be enabled from the SystemC side by calling the function,</p><blockquote><pre>uvmc_enable_trans_mm();</pre></blockquote><p>at initialization time.</p><p>You will see that the <i>4phase.connections/</i> examples below use this function to enable memory management and thus, by implication, to enable the transaction preservation feature.</p></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h2 class=CTitle><a name="4-phase_connection_examples" href="../../../uvmc/examples/4phase.connections/README.txt">4-phase connection examples</a></h2><div class=CBody><p>In a 4-phase operation during which the RESP phases are deployed by the target&rsquo;s call to <i>nb_transport_bw()</i> then it is assumed that the passed in transaction reference will be one matched in the <i>nb_transport_fw()</i> call.</p><p>However, it will only do this if there is a match in the transaction preservation table to the original transaction passed in via the REQ phases.</p><p>If there is a match, the UVMC infrastructure on the SV or SC initiator side will guarantee that the same transaction that was passed into <i>nb_transport_fw()</i> during the REQ phases will be reflected back to that initiator&rsquo;s <i>nb_transport_bw()</i> callback during the RESP phases.&nbsp; Thus the original TLM GP reference will be preserved through all 4 phases of the TLM-2.0 base protocol.</p><p>However, WORD OF CAUTION: if the target does not pass the same TLM GP ref to <i>nb_transport_bw()</i> as was received via <i>nb_transport_fw()</i> a memory leak will result.&nbsp; This is because there is otherwise no way to know when it is safe to return that TLM GP back to the heap.</p><p>Fortunately there is a sanity check that is called when -DDEBUG is enabled that captures heap statistics from the <i>uvmc_trans_mm&lt;T&gt;</i> memory heap manager on all alloc and free operations.&nbsp; At the end of the simulation function calls can be made to print all heap statistics.&nbsp; These statistics will clearly indicate if any memory leakage has occurred.&nbsp; These calls exist for both <i>uvmc_tlm_gp_mm</i> and <i>uvmc_trans_mm</i> heap managers,</p><blockquote><pre>uvmc_tlm_gp_mm_base::printAllStats();
uvmc_trans_mm_base::printAllStats();</pre></blockquote><p>There is also a warning that the infrastructure will automatically put out for any unmatched transactions if they are detected in the RESP phase as well.</p><p>All the 4-phase examples are <i>initator -&gt; target</i>, then loopback of <i>initiator -&gt; target</i> in the other direction.</p><p>So for example,</p><ul><li>SV initator -&gt; SC target -&gt; loopback -&gt; SC initator -&gt; SV target</li><li>SC initator -&gt; SV target -&gt; loopback -&gt; SV initator -&gt; SC target</li></ul><p>So the naming of that above would be, respectively,</p><ul><li>sv2sc2sv_loopback # See <a href="common/producer_loopback-h.html#SC.SV.SC_4-phase_loopback_example" class=LSection >SC -&gt; SV -&gt; SC 4-phase loopback example</a></li><li>sc2sv2sc_loopback # See <a href="common/producer_loopback-svh.html#SV.SC.SV_4-phase_loopback_example" class=LSection >SV -&gt; SC -&gt; SV 4-phase loopback example</a></li></ul><p>There are additional variations that use optimized TLM GP transaction types as well,</p><ul><li>sc2sv2sc_gp_converter_loopback</li><li>sv2sc2sv_gp_converter_loopback</li><li>sc2sv2sc_xl_gp_converter_loopback</li><li>sv2sc2sv_xl_gp_converter_loopback</li></ul><p>In each case the first <i>initator -&gt; target</i> is 4-phase and demonstrates the 4-phase operation described above with transaction preservation and memory management.</p><p>And the <i>initator -&gt; target</i> in the other direction is just 2-phase <i>b_transport()</i>.</p><p>In some of the examples the memory management and transaction preservation support is turned on mid-simulation.&nbsp; So they start out as legacy operation then switch to the new mode.&nbsp; They also send some of the transactions as intentionally non-matching (i.e. undisciplined target) to trigger the resulting warnings that the UVMC infrastructure puts out when this happens.</p><p>Best thing to do is examine the source code for the examples and run them to get a feel for how this happens.&nbsp; Subsequent sections of this doc also explain more details about how the specific loopback examples work.</p></div></div></div>




 <!--CONTENT index=4 -->
<div class="CGeneric"><div class=CTopic><h2 class=CTitle><a name="Running_the_examples" href="../../../uvmc/examples/4phase.connections/README.txt">Running the examples</a></h2><div class=CBody><p>For examples that demonstrate the 4-phase operation see,</p><blockquote><pre>examples/4phase.connections/Makefile</pre></blockquote><p>This directory contains several examples of TLM-2 UVM-Connect&rsquo;ions that pass TLM-2 generic payloads (TLM GPs) between SystemC (SC) and SystemVerilog (SV) andenable the transction preservation feature.</p><p>Use <i>make help</i> to view the menu of available tests,</p><blockquote><pre>make help</pre></blockquote><p>To run just one test such as <i>sc2sv2sc_loopback</i>,</p><blockquote><pre>make sc2sv2sc_loopback</pre></blockquote><p>This compiles then runs the <i>sc2sv2sc_loopback</i> test.</p><p>To run all tests, check them, and clean up afterwards, i.e.&nbsp; <i>sim:</i>, <i>check:</i>, and <i>clean:</i> targets, use the <i>all:</i> target as follows,</p><blockquote><pre>make all</pre></blockquote><p>Or you can run individual sub-targets.</p><p>The <i>sim</i> target compiles and runs all the tests.</p><blockquote><pre>make sim</pre></blockquote><p>The <i>check</i> target checks results of all the tests.</p><blockquote><pre>make check</pre></blockquote><p>The <i>clean</i> target deletes all the simulation files produced from previous runs.</p><blockquote><pre>make clean</pre></blockquote><p>You can combine targets in one command line</p><blockquote><pre>make sim check</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>